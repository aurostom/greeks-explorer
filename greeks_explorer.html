<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Options Greeks Explorer (Black–Scholes)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b33;
      --text:#e7eefc;
      --muted:#a9b7d3;
      --line:rgba(255,255,255,.10);
      --accent:#7aa2ff;   /* Call */
      --accent2:#ffb86b;  /* Put */
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 10% 0%, #13234a 0%, rgba(19,35,74,0) 60%),
                  radial-gradient(900px 500px at 100% 20%, #2a1a44 0%, rgba(42,26,68,0) 55%),
                  var(--bg);
      color:var(--text);
      font-family:var(--sans);
    }
    #app{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
      padding:14px;
      min-height:100vh;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .left{
      padding:14px;
      position:sticky;
      top:14px;
      height:calc(100vh - 28px);
      overflow:auto;
    }
    h1{
      font-size:16px;
      margin:0 0 8px 0;
      letter-spacing:.2px;
    }
    .sub{
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
      margin-bottom:10px;
    }
    .group{
      padding:10px;
      background: rgba(0,0,0,.16);
      border:1px solid var(--line);
      border-radius:12px;
      margin:10px 0;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:8px 0;
    }
    label{
      font-size:12px;
      color:var(--muted);
    }
    .seg{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .seg label{
      color:var(--text);
      font-size:12px;
      display:flex;
      gap:6px;
      align-items:center;
      padding:6px 8px;
      border:1px solid var(--line);
      border-radius:10px;
      background: rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
    }
    .seg input{ accent-color: var(--accent); }
    .seg .put input{ accent-color: var(--accent2); }
    .param{
      display:grid;
      grid-template-columns: 1fr 120px;
      gap:10px;
      align-items:center;
      margin:10px 0;
    }
    .param .meta{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:4px;
    }
    .param .meta .name{
      font-size:12px;
      color:var(--muted);
    }
    .param .meta .val{
      font-family:var(--mono);
      font-size:12px;
      color:var(--text);
      opacity:.95;
    }
    .param input[type="range"]{ width:100%; }
    input[type="number"]{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      color:var(--text);
      font-family:var(--mono);
      outline:none;
    }
    input[type="number"]:focus{
      border-color: rgba(122,162,255,.6);
      box-shadow: 0 0 0 3px rgba(122,162,255,.15);
    }
    button{
      padding:9px 10px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(122,162,255,.14);
      color: var(--text);
      cursor:pointer;
      font-size:12px;
    }
    button:hover{ background: rgba(122,162,255,.22); }

    .readout{
      display:grid;
      gap:8px;
      padding:10px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--line);
      border-radius:12px;
      margin-top:10px;
    }
    .readout .title{
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .table{
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      overflow:hidden;
      font-family:var(--mono);
      font-size:12px;
    }
    .trow{
      display:grid;
      grid-template-columns: 120px 1fr 1fr;
      gap:0;
    }
    .trow.two{
      grid-template-columns: 120px 1fr;
    }
    .tcell{
      padding:8px 10px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    .trow:first-child .tcell{ border-top:none; background: rgba(255,255,255,.03); }
    .thead{
      color:var(--muted);
      font-family:var(--sans);
      font-size:12px;
    }
    .callTxt{ color: var(--accent); }
    .putTxt{ color: var(--accent2); }

    .right{
      padding:14px;
      overflow:hidden;
    }
    .charts{
      display:grid;
      grid-template-columns: repeat(2, minmax(260px, 1fr));
      gap:12px;
    }
    .chart-card{
      padding:10px;
      background: rgba(0,0,0,.16);
      border:1px solid var(--line);
      border-radius:12px;
      position:relative;
      min-height:260px;
    }
    .chart-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .chart-title .name{
      font-size:12px;
      color:var(--muted);
    }
    .legend{
      display:flex;
      gap:10px;
      align-items:center;
      font-size:11px;
      color:var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .dot{
      width:10px;height:10px;border-radius:99px;display:inline-block;
      border:1px solid rgba(255,255,255,.25);
      margin-right:6px;
      transform: translateY(1px);
    }
    .dot.call{ background: var(--accent); }
    .dot.put{ background: var(--accent2); }
    .mutedOff{ opacity:.35; }
    canvas{
      width:100%;
      height:210px;
      display:block;
      border-radius:10px;
      background: rgba(255,255,255,.02);
      border:1px solid rgba(255,255,255,.07);
      touch-action:none; /* enable pointer pan/zoom */
      cursor: grab;
    }
    canvas:active{ cursor: grabbing; }

    .footer{
      margin-top:10px;
      font-size:11px;
      color:var(--muted);
      line-height:1.35;
    }

    @media (max-width: 980px){
      #app{ grid-template-columns: 1fr; }
      .left{ position:relative; height:auto; }
      .charts{ grid-template-columns: 1fr; }
      canvas{ height:240px; }
    }
  </style>
</head>

<body>
<div id="app">
  <div class="card left">
    <h1>Options Greeks Explorer (Black–Scholes)</h1>
    <div class="sub">
      Sliders update curves live. Axes are <b>fixed</b> when inputs change (until you pan/zoom).
      <br/>Interaction: <b>drag</b> to pan • <b>mouse wheel</b> / <b>trackpad</b> to zoom • <b>double‑click</b> a chart to reset its view.
    </div>

    <div class="group">
      <div class="row">
        <label>Curves to display</label>
        <div class="seg">
          <label class="call"><input type="checkbox" id="showCall" checked> Call</label>
          <label class="put"><input type="checkbox" id="showPut" checked> Put</label>
        </div>
      </div>
      <div class="row">
        <label>Units</label>
        <div class="seg">
          <label title="Vega shown per 1% IV change (instead of per 1.00 = 100% vol)">
            <input type="checkbox" id="vegaPer1pct" checked> Vega / 1%
          </label>
          <label title="Rho shown per 1% rate change (instead of per 1.00 = 100% rate)">
            <input type="checkbox" id="rhoPer1pct" checked> Rho / 1%
          </label>
          <label title="Theta shown per day (instead of per year)">
            <input type="checkbox" id="thetaPerDay" checked> Theta / day
          </label>
        </div>
      </div>
    </div>

    <div class="group" id="params"></div>

    <div class="row">
      <button id="resetInputsBtn">Reset inputs</button>
      <button id="resetViewBtn" title="Reset x-axis to 0..100 and reset y-ranges to defaults">Reset axes</button>
    </div>

    <div class="readout">
      <div class="title">
        <span>At current spot</span>
        <span style="font-family:var(--mono);">S=<span id="spotRead"></span>, K=<span id="strikeRead"></span></span>
      </div>
      <div class="table" id="readTable"></div>
    </div>

    <div class="footer">
      Vertical reference lines: <span class="callTxt">spot</span> (dashed) and <span class="putTxt">strike</span> (dotted).
      <br/>Assumes European exercise, no dividends, continuous compounding.
    </div>
  </div>

  <div class="card right">
    <div class="charts">
      <div class="chart-card">
        <div class="chart-title">
          <div class="name">Delta (∂Price/∂S)</div>
          <div class="legend" id="legendDelta"></div>
        </div>
        <canvas id="cDelta"></canvas>
      </div>

      <div class="chart-card">
        <div class="chart-title">
          <div class="name">Gamma (∂²Price/∂S²)</div>
          <div class="legend" id="legendGamma"></div>
        </div>
        <canvas id="cGamma"></canvas>
      </div>

      <div class="chart-card">
        <div class="chart-title">
          <div class="name">Vega (∂Price/∂σ)</div>
          <div class="legend" id="legendVega"></div>
        </div>
        <canvas id="cVega"></canvas>
      </div>

      <div class="chart-card">
        <div class="chart-title">
          <div class="name">Theta (∂Price/∂t)</div>
          <div class="legend" id="legendTheta"></div>
        </div>
        <canvas id="cTheta"></canvas>
      </div>

      <div class="chart-card" style="grid-column: 1 / -1;">
        <div class="chart-title">
          <div class="name">Rho (∂Price/∂r)</div>
          <div class="legend" id="legendRho"></div>
        </div>
        <canvas id="cRho"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // -------- Normal CDF/PDF --------
  function erf(x){
    const sign = x >= 0 ? 1 : -1;
    x = Math.abs(x);
    const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
    const p=0.3275911;
    const t = 1 / (1 + p*x);
    const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t * Math.exp(-x*x);
    return sign * y;
  }
  function normCdf(x){ return 0.5*(1 + erf(x / Math.SQRT2)); }
  function normPdf(x){ return Math.exp(-0.5*x*x) / Math.sqrt(2*Math.PI); }

  // -------- Black-Scholes Greeks (no dividends) --------
  function bsGreeks(S, K, T, sigma, r, isCall){
    const eps = 1e-12;
    S = Math.max(S, eps);
    K = Math.max(K, eps);
    T = Math.max(T, 1e-10);
    sigma = Math.max(sigma, 1e-10);

    const sqrtT = Math.sqrt(T);
    const d1 = (Math.log(S/K) + (r + 0.5*sigma*sigma)*T) / (sigma*sqrtT);
    const d2 = d1 - sigma*sqrtT;

    const Nd1 = normCdf(d1);
    const Nd2 = normCdf(d2);
    const Nnd1 = normCdf(-d1);
    const Nnd2 = normCdf(-d2);
    const nd1 = normPdf(d1);
    const disc = Math.exp(-r*T);

    const price = isCall
      ? (S * Nd1 - K * disc * Nd2)
      : (K * disc * Nnd2 - S * Nnd1);

    const delta = isCall ? Nd1 : (Nd1 - 1);
    const gamma = nd1 / (S * sigma * sqrtT);
    const vega  = S * nd1 * sqrtT;
    const theta = isCall
      ? (-(S*nd1*sigma)/(2*sqrtT) - r*K*disc*Nd2)
      : (-(S*nd1*sigma)/(2*sqrtT) + r*K*disc*Nnd2);
    const rho = isCall
      ? (K * T * disc * Nd2)
      : (-K * T * disc * Nnd2);

    return { price, delta, gamma, vega, theta, rho };
  }

  // -------- Formatting / ticks --------
  function fmt(x){
    if (!isFinite(x)) return "—";
    const a = Math.abs(x);
    if (a === 0) return "0";
    if (a >= 1e6 || a < 1e-4) return x.toExponential(3);
    if (a < 1) return x.toFixed(5).replace(/0+$/,'').replace(/\.$/,'');
    if (a < 100) return x.toFixed(4).replace(/0+$/,'').replace(/\.$/,'');
    return x.toFixed(3).replace(/0+$/,'').replace(/\.$/,'');
  }
  function niceStep(range, targetTicks=6){
    const raw = range / Math.max(1, (targetTicks-1));
    const exp = Math.floor(Math.log10(raw));
    const frac = raw / Math.pow(10, exp);
    let nice;
    if (frac <= 1) nice = 1;
    else if (frac <= 2) nice = 2;
    else if (frac <= 5) nice = 5;
    else nice = 10;
    return nice * Math.pow(10, exp);
  }
  function buildTicks(min, max, targetTicks=6){
    if (!isFinite(min) || !isFinite(max) || min === max){
      const v = isFinite(min) ? min : 0;
      return { ticks: [v-1, v, v+1] };
    }
    const range = max - min;
    const step = niceStep(range, targetTicks);
    const tmin = Math.floor(min/step) * step;
    const tmax = Math.ceil(max/step) * step;
    const ticks = [];
    for (let t = tmin; t <= tmax + step*0.5; t += step) ticks.push(t);
    return { ticks };
  }
  function clamp(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }

  // -------- Layout helpers --------
  const PAD = { L: 50, R: 12, T: 12, B: 30 };
  function getPlotRect(canvas){
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;
    const x0 = PAD.L, y0 = PAD.T;
    const x1 = W - PAD.R, y1 = H - PAD.B;
    return { W, H, x0, y0, x1, y1, w: (x1-x0), h: (y1-y0) };
  }
  function localPos(e, canvas){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.clientWidth / rect.width);
    const y = (e.clientY - rect.top) * (canvas.clientHeight / rect.height);
    return { x, y };
  }

  // -------- Chart drawing (fixed view) --------
  function drawChart(canvas, series, viewX, viewY, refs){
    const ctx = canvas.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    canvas.width = Math.max(1, Math.round(cssW * dpr));
    canvas.height = Math.max(1, Math.round(cssH * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const { W, H, x0, y0, x1, y1, w, h } = getPlotRect(canvas);

    // Background
    ctx.clearRect(0,0,W,H);

    const xMin = viewX.min, xMax = viewX.max;
    const yMin = viewY.min, yMax = viewY.max;
    const xRange = xMax - xMin;
    const yRange = yMax - yMin;

    const X = x => x0 + (x - xMin) * (w / xRange);
    const Y = y => y1 - (y - yMin) * (h / yRange);

    // Axes
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0, y1);
    ctx.lineTo(x1, y1);
    ctx.stroke();

    // Grid + ticks
    const xt = buildTicks(xMin, xMax, 6);
    const yt = buildTicks(yMin, yMax, 6);

    ctx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue('--mono').trim();
    ctx.strokeStyle = "rgba(255,255,255,.08)";

    // X ticks
    for (const t of xt.ticks){
      const xp = X(t);
      ctx.beginPath();
      ctx.moveTo(xp, y0);
      ctx.lineTo(xp, y1);
      ctx.stroke();
      ctx.fillStyle = "rgba(231,238,252,.72)";
      const txt = fmt(t);
      const tw = ctx.measureText(txt).width;
      ctx.fillText(txt, xp - tw/2, H - 10);
    }

    // Y ticks
    for (const t of yt.ticks){
      const yp = Y(t);
      ctx.beginPath();
      ctx.moveTo(x0, yp);
      ctx.lineTo(x1, yp);
      ctx.stroke();
      ctx.fillStyle = "rgba(231,238,252,.72)";
      const txt = fmt(t);
      const tw = ctx.measureText(txt).width;
      ctx.fillText(txt, x0 - 8 - tw, yp + 4);
    }

    // Zero line (if visible)
    if (yMin < 0 && yMax > 0){
      ctx.strokeStyle = "rgba(99,230,190,.18)";
      ctx.lineWidth = 1;
      const yz = Y(0);
      ctx.beginPath();
      ctx.moveTo(x0, yz);
      ctx.lineTo(x1, yz);
      ctx.stroke();
    }

    // Ref lines: spot (dashed) and strike (dotted)
    if (refs){
      if (typeof refs.spot === "number" && refs.spot >= xMin && refs.spot <= xMax){
        const xs = X(refs.spot);
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle = "rgba(122,162,255,.40)";
        ctx.beginPath(); ctx.moveTo(xs, y0); ctx.lineTo(xs, y1); ctx.stroke();
        ctx.restore();
      }
      if (typeof refs.strike === "number" && refs.strike >= xMin && refs.strike <= xMax){
        const xk = X(refs.strike);
        ctx.save();
        ctx.setLineDash([2,4]);
        ctx.strokeStyle = "rgba(255,184,107,.40)";
        ctx.beginPath(); ctx.moveTo(xk, y0); ctx.lineTo(xk, y1); ctx.stroke();
        ctx.restore();
      }
    }

    // Clip to plot area
    ctx.save();
    ctx.beginPath();
    ctx.rect(x0, y0, w, h);
    ctx.clip();

    // Plot each series
    for (const s of series){
      if (!s.visible) continue;
      ctx.lineWidth = 2;
      ctx.strokeStyle = s.stroke;
      ctx.beginPath();
      let started = false;
      for (const p of s.data){
        if (!isFinite(p.y)) { started = false; continue; }
        const xp = X(p.x), yp = Y(p.y);
        if (!started){ ctx.moveTo(xp, yp); started = true; }
        else ctx.lineTo(xp, yp);
      }
      ctx.stroke();

      // Spot marker
      if (refs && typeof refs.spot === "number" && refs.spot >= xMin && refs.spot <= xMax && isFinite(s.markerY)){
        const xp = X(refs.spot), yp = Y(s.markerY);
        ctx.fillStyle = s.stroke;
        ctx.beginPath(); ctx.arc(xp, yp, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,.35)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // -------- State --------
  const defaultState = {
    spot: 50,    // changed so default x-axis 0..100 feels centered
    strike: 50,
    tYears: 0.50,
    ivPct: 25,
    rPct: 5,
    showCall: true,
    showPut: true,
    vegaPer1pct: true,
    rhoPer1pct: true,
    thetaPerDay: true,
  };
  let state = JSON.parse(JSON.stringify(defaultState));

  // Shared X view across all charts (default 0..100)
  let xView = { min: 0, max: 100 };

  // Y views per chart (defaults chosen for common ranges under typical params)
  const yViews = {
    delta: { min: -1.05, max:  1.05 },
    gamma: { min:  0.00, max:  0.20 },
    vega:  { min:  0.00, max:  1.00 },  // per 1% vol by default
    theta: { min: -0.50, max:  0.20 },  // per day by default
    rho:   { min: -1.00, max:  1.00 },  // per 1% rate by default
  };

  function defaultYFor(key){
    // Scale defaults based on unit toggles (so "Reset axes" stays sensible)
    if (key === "vega"){
      const mult = state.vegaPer1pct ? 1 : 100;
      return { min: 0.00 * mult, max: 1.00 * mult };
    }
    if (key === "rho"){
      const mult = state.rhoPer1pct ? 1 : 100;
      return { min: -1.00 * mult, max: 1.00 * mult };
    }
    if (key === "theta"){
      const mult = state.thetaPerDay ? 1 : 365;
      return { min: -0.50 * mult, max: 0.20 * mult };
    }
    if (key === "gamma") return { min: 0.00, max: 0.20 };
    if (key === "delta") return { min: -1.05, max: 1.05 };
    return { min: -1, max: 1 };
  }

  // -------- UI build --------
  const paramsEl = document.getElementById("params");
  const showCallEl = document.getElementById("showCall");
  const showPutEl = document.getElementById("showPut");
  const vegaPer1pctEl = document.getElementById("vegaPer1pct");
  const rhoPer1pctEl  = document.getElementById("rhoPer1pct");
  const thetaPerDayEl = document.getElementById("thetaPerDay");
  const spotReadEl = document.getElementById("spotRead");
  const strikeReadEl = document.getElementById("strikeRead");
  const readTableEl = document.getElementById("readTable");

  function makeParam({id, name, hint, min, max, step, unit, format, get, set, dynamicRange}){
    const wrap = document.createElement("div");
    wrap.className = "param";

    const left = document.createElement("div");
    const meta = document.createElement("div");
    meta.className = "meta";
    const nm = document.createElement("div");
    nm.className = "name";
    nm.textContent = name;
    if (hint) nm.title = hint;

    const val = document.createElement("div");
    val.className = "val";
    val.id = id + "_val";

    meta.appendChild(nm);
    meta.appendChild(val);

    const range = document.createElement("input");
    range.type = "range";
    range.id = id + "_range";
    range.min = min; range.max = max; range.step = step;

    left.appendChild(meta);
    left.appendChild(range);

    const numWrap = document.createElement("div");
    const num = document.createElement("input");
    num.type = "number";
    num.id = id + "_num";
    num.min = min; num.max = max; num.step = step;
    numWrap.appendChild(num);

    wrap.appendChild(left);
    wrap.appendChild(numWrap);
    paramsEl.appendChild(wrap);

    function syncUI(){
      const v = get();
      if (dynamicRange){
        const rmin = parseFloat(range.min), rmax = parseFloat(range.max);
        if (v < rmin) range.min = Math.max(0, v * 0.5);
        if (v > rmax) range.max = v * 2;
        num.min = range.min; num.max = range.max;
      }
      range.value = v;
      num.value = v;
      val.textContent = (format ? format(v) : (fmt(v) + (unit||"")));
    }

    function onAnyInput(v){
      const nv = Number(v);
      if (!isFinite(nv)) return;
      set(nv);
      syncUI();
      render(); // axes stay fixed; only curves update
    }

    range.addEventListener("input", e => onAnyInput(e.target.value));
    num.addEventListener("input", e => onAnyInput(e.target.value));
    syncUI();

    return { syncUI };
  }

  function buildParams(){
    paramsEl.innerHTML = "";
    makeParam({
      id: "spot", name: "Spot (S)", hint: "Underlying price",
      min: 0.01, max: 200, step: 0.1,
      dynamicRange: true,
      get: () => state.spot,
      set: v => state.spot = Math.max(0.01, v),
      format: v => fmt(v)
    });
    makeParam({
      id: "strike", name: "Strike (K)", hint: "Option strike price",
      min: 0.01, max: 200, step: 0.1,
      dynamicRange: true,
      get: () => state.strike,
      set: v => state.strike = Math.max(0.01, v),
      format: v => fmt(v)
    });
    makeParam({
      id: "tYears", name: "Time to expiry (T, years)", hint: "Decimal years (e.g., 0.25 ≈ 3 months)",
      min: 0.001, max: 5, step: 0.001,
      get: () => state.tYears,
      set: v => state.tYears = Math.max(1e-6, v),
      format: v => fmt(v) + "y"
    });
    makeParam({
      id: "ivPct", name: "Implied volatility (σ, %)", hint: "Annualized volatility as percent",
      min: 1, max: 300, step: 0.1,
      get: () => state.ivPct,
      set: v => state.ivPct = Math.max(0.0001, v),
      format: v => fmt(v) + "%"
    });
    makeParam({
      id: "rPct", name: "Risk-free rate (r, %)", hint: "Continuously compounded risk-free rate",
      min: -10, max: 25, step: 0.01,
      get: () => state.rPct,
      set: v => state.rPct = v,
      format: v => fmt(v) + "%"
    });
  }

  buildParams();

  function ensureAtLeastOneCurve(){
    if (!state.showCall && !state.showPut){
      state.showCall = true;
      showCallEl.checked = true;
    }
  }

  showCallEl.addEventListener("change", () => {
    state.showCall = showCallEl.checked;
    ensureAtLeastOneCurve();
    render();
  });
  showPutEl.addEventListener("change", () => {
    state.showPut = showPutEl.checked;
    ensureAtLeastOneCurve();
    render();
  });

  vegaPer1pctEl.addEventListener("change", () => { state.vegaPer1pct = vegaPer1pctEl.checked; render(); });
  rhoPer1pctEl.addEventListener("change",  () => { state.rhoPer1pct  = rhoPer1pctEl.checked;  render(); });
  thetaPerDayEl.addEventListener("change", () => { state.thetaPerDay = thetaPerDayEl.checked; render(); });

  document.getElementById("resetInputsBtn").addEventListener("click", () => {
    state = JSON.parse(JSON.stringify(defaultState));
    showCallEl.checked = state.showCall;
    showPutEl.checked = state.showPut;
    vegaPer1pctEl.checked = state.vegaPer1pct;
    rhoPer1pctEl.checked = state.rhoPer1pct;
    thetaPerDayEl.checked = state.thetaPerDay;
    buildParams();
    render();
  });

  document.getElementById("resetViewBtn").addEventListener("click", () => {
    xView = { min: 0, max: 100 };
    for (const k of Object.keys(yViews)){
      yViews[k] = defaultYFor(k);
    }
    render();
  });

  // -------- Compute curves in current xView --------
  function computeCurves(){
    const S0 = state.spot;
    const K  = state.strike;
    const T  = state.tYears;
    const sigma = state.ivPct / 100;
    const r = state.rPct / 100;

    const xMin = xView.min;
    const xMax = xView.max;
    const N = 260;

    const unitVega = state.vegaPer1pct ? 0.01 : 1.0;
    const unitRho  = state.rhoPer1pct  ? 0.01 : 1.0;
    const unitTheta= state.thetaPerDay ? (1/365) : 1.0;

    const xs = new Array(N);
    const call = { delta:[], gamma:[], vega:[], theta:[], rho:[] };
    const put  = { delta:[], gamma:[], vega:[], theta:[], rho:[] };

    for (let i=0;i<N;i++){
      const x = xMin + (xMax - xMin) * (i/(N-1));
      xs[i] = x;

      const S = Math.max(1e-10, x); // allow axis to show 0, but compute safely
      const gc = bsGreeks(S, K, T, sigma, r, true);
      const gp = bsGreeks(S, K, T, sigma, r, false);

      call.delta.push({x, y: gc.delta});
      call.gamma.push({x, y: gc.gamma});
      call.vega .push({x, y: gc.vega * unitVega});
      call.theta.push({x, y: gc.theta * unitTheta});
      call.rho  .push({x, y: gc.rho  * unitRho});

      put.delta.push({x, y: gp.delta});
      put.gamma.push({x, y: gp.gamma});
      put.vega .push({x, y: gp.vega * unitVega});
      put.theta.push({x, y: gp.theta * unitTheta});
      put.rho  .push({x, y: gp.rho  * unitRho});
    }

    const atSpotCall = bsGreeks(S0, K, T, sigma, r, true);
    const atSpotPut  = bsGreeks(S0, K, T, sigma, r, false);

    const atSpot = {
      call: {
        price: atSpotCall.price,
        delta: atSpotCall.delta,
        gamma: atSpotCall.gamma,
        vega:  atSpotCall.vega * unitVega,
        theta: atSpotCall.theta * unitTheta,
        rho:   atSpotCall.rho  * unitRho
      },
      put: {
        price: atSpotPut.price,
        delta: atSpotPut.delta,
        gamma: atSpotPut.gamma,
        vega:  atSpotPut.vega * unitVega,
        theta: atSpotPut.theta * unitTheta,
        rho:   atSpotPut.rho  * unitRho
      }
    };

    return { call, put, atSpot };
  }

  // -------- Legends + readout --------
  const callColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
  const putColor  = getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim();

  function setLegend(elId){
    const el = document.getElementById(elId);
    const callClass = state.showCall ? "" : "mutedOff";
    const putClass  = state.showPut  ? "" : "mutedOff";
    el.innerHTML =
      `<span class="${callClass}"><span class="dot call"></span>Call</span>` +
      `<span class="${putClass}"><span class="dot put"></span>Put</span>`;
  }

  function readoutLabels(){
    const vegaLabel = state.vegaPer1pct ? "Vega (/1%)" : "Vega (/1.00)";
    const rhoLabel  = state.rhoPer1pct  ? "Rho (/1%)"  : "Rho (/1.00)";
    const thetaLabel= state.thetaPerDay ? "Theta (/day)" : "Theta (/year)";
    return { vegaLabel, rhoLabel, thetaLabel };
  }

  function renderReadout(curves){
    spotReadEl.textContent = fmt(state.spot);
    strikeReadEl.textContent = fmt(state.strike);

    const { vegaLabel, rhoLabel, thetaLabel } = readoutLabels();
    const metrics = [
      ["Price", "price"],
      ["Delta", "delta"],
      ["Gamma", "gamma"],
      [vegaLabel, "vega"],
      [thetaLabel, "theta"],
      [rhoLabel, "rho"]
    ];

    const showBoth = state.showCall && state.showPut;
    const showOne = (state.showCall ^ state.showPut);

    readTableEl.innerHTML = "";

    // Header
    if (showBoth){
      const h = document.createElement("div");
      h.className = "trow";
      h.innerHTML =
        `<div class="tcell thead">Metric</div>` +
        `<div class="tcell thead callTxt">Call</div>` +
        `<div class="tcell thead putTxt">Put</div>`;
      readTableEl.appendChild(h);

      for (const [label, key] of metrics){
        const r = document.createElement("div");
        r.className = "trow";
        r.innerHTML =
          `<div class="tcell">${label}</div>` +
          `<div class="tcell">${fmt(curves.atSpot.call[key])}</div>` +
          `<div class="tcell">${fmt(curves.atSpot.put[key])}</div>`;
        readTableEl.appendChild(r);
      }
      return;
    }

    // Single column (call OR put)
    if (showOne){
      const which = state.showCall ? "call" : "put";
      const whichLabel = state.showCall ? "Call" : "Put";
      const whichClass = state.showCall ? "callTxt" : "putTxt";

      const h = document.createElement("div");
      h.className = "trow two";
      h.innerHTML =
        `<div class="tcell thead">Metric</div>` +
        `<div class="tcell thead ${whichClass}">${whichLabel}</div>`;
      readTableEl.appendChild(h);

      for (const [label, key] of metrics){
        const r = document.createElement("div");
        r.className = "trow two";
        r.innerHTML =
          `<div class="tcell">${label}</div>` +
          `<div class="tcell">${fmt(curves.atSpot[which][key])}</div>`;
        readTableEl.appendChild(r);
      }
      return;
    }

    // Shouldn't happen due to ensureAtLeastOneCurve(), but just in case:
    readTableEl.textContent = "Select Call and/or Put.";
  }

  // -------- Pan/Zoom (shared X, per-chart Y) --------
  function applyConstraints(){
    // keep x >= 0
    const minRangeX = 0.5;
    const maxRangeX = 1e6;
    let rx = xView.max - xView.min;
    rx = clamp(rx, minRangeX, maxRangeX);
    const center = (xView.min + xView.max)/2;
    xView.min = center - rx/2;
    xView.max = center + rx/2;
    if (xView.min < 0){
      xView.max -= xView.min;
      xView.min = 0;
    }

    // per y
    for (const k of Object.keys(yViews)){
      const minRangeY = 1e-6;
      const maxRangeY = 1e12;
      let ry = yViews[k].max - yViews[k].min;
      ry = clamp(ry, minRangeY, maxRangeY);
      const c = (yViews[k].min + yViews[k].max)/2;
      yViews[k].min = c - ry/2;
      yViews[k].max = c + ry/2;
    }
  }

  function zoomAbout(canvas, key, px, py, factor){
    const layout = getPlotRect(canvas);
    const { x0, y0, w, h } = layout;

    const xr = xView.max - xView.min;
    const yr = yViews[key].max - yViews[key].min;

    // Clamp pointer to plot area
    const fx = clamp((px - x0) / w, 0, 1);
    const fy = clamp((py - y0) / h, 0, 1);

    const xData = xView.min + fx * xr;
    const yData = yViews[key].max - fy * yr;

    const newXr = xr * factor;
    const newYr = yr * factor;

    xView.min = xData - fx * newXr;
    xView.max = xView.min + newXr;

    yViews[key].max = yData + fy * newYr;
    yViews[key].min = yViews[key].max - newYr;

    applyConstraints();
  }

  function panBy(canvas, key, dxPx, dyPx){
    const layout = getPlotRect(canvas);
    const { w, h } = layout;

    const xr = xView.max - xView.min;
    const yr = yViews[key].max - yViews[key].min;

    const dxData = (dxPx / w) * xr;
    const dyData = (dyPx / h) * yr;

    // x: subtract to "drag the data"
    xView.min -= dxData;
    xView.max -= dxData;

    // y: add because screen y increases downward
    yViews[key].min += dyData;
    yViews[key].max += dyData;

    applyConstraints();
  }

  function attachInteractions(canvas, key){
    const pointers = new Map();
    let panStart = null;  // {x,y}
    let startXView = null;
    let startYView = null;

    let pinchStart = null; // {dist, mid:{x,y}, xView:{}, yView:{}}

    canvas.addEventListener("dblclick", (e) => {
      // Reset shared x + this chart y to defaults
      xView = { min: 0, max: 100 };
      yViews[key] = defaultYFor(key);
      render();
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const p = localPos(e, canvas);
      const factor = Math.exp(e.deltaY * 0.001); // >1 zoom out
      zoomAbout(canvas, key, p.x, p.y, factor);
      render();
    }, { passive:false });

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      const p = localPos(e, canvas);
      pointers.set(e.pointerId, p);

      if (pointers.size === 1){
        panStart = p;
        startXView = { ...xView };
        startYView = { ...yViews[key] };
      } else if (pointers.size === 2){
        const pts = Array.from(pointers.values());
        const dx = pts[0].x - pts[1].x;
        const dy = pts[0].y - pts[1].y;
        const dist = Math.hypot(dx, dy);
        const mid = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };
        pinchStart = {
          dist,
          mid,
          xView: { ...xView },
          yView: { ...yViews[key] }
        };
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      const p = localPos(e, canvas);
      pointers.set(e.pointerId, p);

      if (pointers.size === 1 && panStart && startXView && startYView){
        // Restore baseline then apply delta (so pan is stable)
        xView = { ...startXView };
        yViews[key] = { ...startYView };

        const dxPx = p.x - panStart.x;
        const dyPx = p.y - panStart.y;
        panBy(canvas, key, dxPx, dyPx);
        render();
      } else if (pointers.size === 2 && pinchStart){
        const pts = Array.from(pointers.values());
        const dx = pts[0].x - pts[1].x;
        const dy = pts[0].y - pts[1].y;
        const dist = Math.hypot(dx, dy);
        if (dist <= 0) return;

        // Start from pinch baseline
        xView = { ...pinchStart.xView };
        yViews[key] = { ...pinchStart.yView };

        const mid = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };

        // Pinch out (dist bigger) => zoom in => factor < 1
        const factor = pinchStart.dist / dist;
        zoomAbout(canvas, key, mid.x, mid.y, factor);
        render();
      }
    });

    function endPointer(e){
      pointers.delete(e.pointerId);
      if (pointers.size < 2) pinchStart = null;
      if (pointers.size === 0){
        panStart = null;
        startXView = null;
        startYView = null;
      }
    }
    canvas.addEventListener("pointerup", endPointer);
    canvas.addEventListener("pointercancel", endPointer);
    canvas.addEventListener("pointerleave", endPointer);
  }

  // -------- Charts registry --------
  const charts = [
    { key:"delta", canvasId:"cDelta", legendId:"legendDelta" },
    { key:"gamma", canvasId:"cGamma", legendId:"legendGamma" },
    { key:"vega",  canvasId:"cVega",  legendId:"legendVega"  },
    { key:"theta", canvasId:"cTheta", legendId:"legendTheta" },
    { key:"rho",   canvasId:"cRho",   legendId:"legendRho"   },
  ];

  // attach interactions + resize rerender
  const ro = new ResizeObserver(() => render());
  for (const c of charts){
    const canvas = document.getElementById(c.canvasId);
    attachInteractions(canvas, c.key);
    ro.observe(canvas);
  }

  // -------- Render --------
  function render(){
    ensureAtLeastOneCurve();

    // update legends
    for (const c of charts) setLegend(c.legendId);

    // compute data
    const curves = computeCurves();
    renderReadout(curves);

    // plot
    const refs = { spot: state.spot, strike: state.strike };

    for (const c of charts){
      const canvas = document.getElementById(c.canvasId);

      const series = [
        {
          name: "Call",
          stroke: callColor,
          visible: !!state.showCall,
          data: curves.call[c.key],
          markerY: curves.atSpot.call[c.key],
        },
        {
          name: "Put",
          stroke: putColor,
          visible: !!state.showPut,
          data: curves.put[c.key],
          markerY: curves.atSpot.put[c.key],
        }
      ];

      drawChart(canvas, series, xView, yViews[c.key], refs);
    }
  }

  // initial
  showCallEl.checked = state.showCall;
  showPutEl.checked  = state.showPut;
  vegaPer1pctEl.checked = state.vegaPer1pct;
  rhoPer1pctEl.checked  = state.rhoPer1pct;
  thetaPerDayEl.checked = state.thetaPerDay;

  // Set yViews to unit-aware defaults at start (in case toggles change)
  for (const k of Object.keys(yViews)){
    yViews[k] = defaultYFor(k);
  }
  render();
})();
</script>
</body>
</html>
